import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

# === Inizializzazione del session_state ===
if 'portfolio' not in st.session_state:
    st.session_state['portfolio'] = []

# === Funzioni di supporto ===
def d1(S, K, T, r, q, sigma):
    return (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))

def d2(S, K, T, r, q, sigma):
    return d1(S, K, T, r, q, sigma) - sigma * np.sqrt(T)

# === Classe per le opzioni ===
class Option:
    def __init__(self, kind, S, K, T, r, q, sigma, qty):
        self.kind = kind  # Tipo di opzione (Call/Put)
        self.S = S        # Spot
        self.K = K        # Strike
        self.T = T        # Tempo a scadenza
        self.r = r        # Tasso di interesse
        self.q = q        # Dividendo
        self.sigma = sigma # Volatilità
        self.qty = qty     # Quantità

    # Funzione per calcolare il prezzo della call (Black-Scholes)
    def bs_call_price(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        d2_val = d2(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return self.S * np.exp(-self.q * self.T) * norm.cdf(d1_val) - self.K * np.exp(-self.r * self.T) * norm.cdf(d2_val)

    # Funzione per calcolare il prezzo della put (Black-Scholes)
    def bs_put_price(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        d2_val = d2(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return self.K * np.exp(-self.r * self.T) * norm.cdf(-d2_val) - self.S * np.exp(-self.q * self.T) * norm.cdf(-d1_val)

    # Metodo per calcolare il payoff dell'opzione alla scadenza
    def payoff(self, spot):
        if self.kind == 'Call':
            return max(spot - self.K, 0)
        elif self.kind == 'Put':
            return max(self.K - spot, 0)

    # === Greche ===
    def delta(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return np.exp(-self.q * self.T) * norm.cdf(d1_val)

    def gamma(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return np.exp(-self.q * self.T) * norm.pdf(d1_val) / (self.S * self.sigma * np.sqrt(self.T))

    def vega(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return self.S * np.exp(-self.q * self.T) * norm.pdf(d1_val) * np.sqrt(self.T)

    def theta(self):
        d1_val = d1(self.S, self.K, self.T, self.r, self.q, self.sigma)
        d2_val = d2(self.S, self.K, self.T, self.r, self.q, self.sigma)
        term1 = -self.S * norm.pdf(d1_val) * self.sigma * np.exp(-self.q * self.T) / (2 * np.sqrt(self.T))
        term2 = -self.r * self.K * np.exp(-self.r * self.T) * norm.cdf(d2_val)
        term3 = self.q * self.S * np.exp(-self.q * self.T) * norm.cdf(d1_val)
        return term1 + term2 + term3

    def rho(self):
        d2_val = d2(self.S, self.K, self.T, self.r, self.q, self.sigma)
        return self.K * self.T * np.exp(-self.r * self.T) * norm.cdf(d2_val)

# === Input dell'utente per una nuova opzione ===
st.header("Aggiungi una nuova opzione al portafoglio")

kind = st.selectbox("Tipo di opzione", ["Call", "Put"])
S = st.number_input("Prezzo Spot (S)", value=100)
K = st.number_input("Strike (K)", value=100)
T = st.number_input("Tempo a scadenza (in anni)", value=1.0)
r = st.number_input("Tasso di interesse (r)", value=0.05)
q = st.number_input("Dividendo (q)", value=0.0)
sigma = st.number_input("Volatilità (σ)", value=0.2)
qty = st.number_input("Quantità", value=1)

# Aggiungi opzione al portfolio
if st.button("Aggiungi al portafoglio"):
    option = Option(kind, S, K, T, r, q, sigma, qty)
    st.session_state['portfolio'].append(option)
    st.success(f"Opzione {kind} aggiunta al portafoglio!")

# === Visualizzazione del portafoglio ===
if 'portfolio' in st.session_state and len(st.session_state['portfolio']) > 0:
    st.header("Portafoglio Attuale")
    
    # Mostra una lista delle opzioni nel portafoglio
    for idx, option in enumerate(st.session_state['portfolio']):
        st.subheader(f"Opzione {idx + 1}: {option.kind}")
        st.write(f"Spot: {option.S}, Strike: {option.K}, Tempo: {option.T}, Quantità: {option.qty}")
        st.write(f"Prezzo Call (Black-Scholes): {option.bs_call_price():.2f}")
        st.write(f"Prezzo Put (Black-Scholes): {option.bs_put_price():.2f}")
        
        # Visualizza le greche per ogni opzione
        st.write(f"Delta: {option.delta():.4f}")
        st.write(f"Gamma: {option.gamma():.4f}")
        st.write(f"Vega: {option.vega():.4f}")
        st.write(f"Theta: {option.theta():.4f}")
        st.write(f"Rho: {option.rho():.4f}")
    
    # Calcolo del payoff complessivo
    st.header("Grafico del Payoff Complessivo del Portafoglio")
    
    # Range di prezzi spot per il grafico
    spot_range = np.linspace(0, 200, 100)
    total_payoff = np.zeros_like(spot_range)
    
    for option in st.session_state['portfolio']:
        total_payoff += option.qty * np.array([option.payoff(spot) for spot in spot_range])
    
    # Visualizza il grafico
    plt.plot(spot_range, total_payoff)
    plt.title("Payoff Complessivo del Portafoglio")
    plt.xlabel("Prezzo Spot alla Scadenza")
    plt.ylabel("Payoff")
    st.pyplot(plt)
